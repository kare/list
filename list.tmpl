// Code generated by "gends"; DO NOT EDIT.

package list // import "kkn.fi/list"

// {{.TypeName}} holds an ordered collection of {{.Type}}'s.
type {{.TypeName}} struct {
	values []{{.Type}}
}

// New{{.TypeName}} creates an empty list of {{.TypeName}}'s.
func New{{.TypeName}}() *{{.TypeName}} {
	return &{{.TypeName}}{}
}

// New{{.TypeName}}With creates a list of {{.TypeName}}'s filled with given
// values.
func New{{.TypeName}}With(values ...{{.Type}}) *{{.TypeName}} {
	return &{{.TypeName}}{
		values: values,
	}
}

// Equals checks list equality given other list. In order to be equal both lists
// must be of same type.
func (l *{{.TypeName}}) Equals(other interface{}) bool {
	list, ok := other.(*{{.TypeName}})
	if !ok {
		return false
	}
	if len(l.values) != len(list.values) {
		return false
	}
	for i, v := range list.Slice() {
		if v != l.values[i] {
			return false
		}
	}
	return true

}

// Add appends a value to the end of the list.
func (l *{{.TypeName}}) Add(value {{.Type}}) {
	l.values = append(l.values, value)
}

// AddAll appends all given values to the end of the list.
func (l *{{.TypeName}}) AddAll(values ...{{.Type}}) {
	l.values = append(l.values, values...)
}

// Get returns the {{.Type}} element at given index.
func (l *{{.TypeName}}) Get(index int) {{.Type}} {
	return l.values[index]
}

// Len returns the size of the list.
func (l *{{.TypeName}}) Len() int {
	return len(l.values)
}

// IsEmpty return true if list is empty, false otherwise.
func (l *{{.TypeName}}) IsEmpty() bool {
	return len(l.values) == 0
}

// Contains returns true if given value is contained by the list, false
// otherwise.
func (l *{{.TypeName}}) Contains(value {{.Type}}) bool {
	for _, v := range l.values {
		if v == value {
			return true
		}
	}
	return false
}

// Slice returns {{.Type}} slice of the elements contained within the list.
func (l *{{.TypeName}}) Slice() []{{.Type}} {
	return l.values
}

// Remove deletes the given value from the list. Returns true if the list
// contained specified value, false otherwise.
func (l *{{.TypeName}}) Remove(value {{.Type}}) bool {
	for i, v := range l.values {
		if v == value {
			l.values = append(l.values[:i], l.values[i+1:]...)
			return true
		}
	}
	return false
}
